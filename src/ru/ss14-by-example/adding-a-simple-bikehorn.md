# Добавление Простого Велосипедного Гудка

{{#template ../templates/outdated.md}}

В этом руководстве объясняется система **entity component system** (ECS) и другие ключевые темы кодовой базы SS14 на примере реализации клоунского гудка с нуля. Вы можете следовать шагам сами или просто ознакомиться с материалом.

## Сущности, компоненты и системы

Хотя Space Station 14 написана на языке программирования C#, который является объектно-ориентированным, для представления игровых объектов используется другая модель данных, называемая *entity component system* (ECS). (*Почему мы используем ECS? См. [ECS](../robust-toolbox/ecs.md)*)

### Сущности

Каждый объект в игре представлен *сущностью*. Игроки, бананы, электрошокеры — всё это сущности. Каждая сущность представлена целым числом, и у двух сущностей не может быть одинакового числа.

Сами по себе сущности только идентифицируют объекты и не имеют поведения, если у них нет компонентов.

### Компоненты

*Компоненты* выполняют две основные функции:

1. **Отмечают конкретные сущности для придания им специфического поведения.** Например, в одной игре сущность с числом 37629 содержит компоненты `NukeComponent` и `ActivatableUIComponent`, что означает, что она ведёт себя как ядерная бомба с возможностью открытия пользовательского интерфейса.

2. **Хранят данные, необходимые для обработки поведения.** Например, у `NukeComponent` может быть поле `Timer`, показывающее, сколько времени осталось до взрыва.

Тем не менее, компоненты не содержат логику для обработки поведения. Поведение реализуется через системы сущностей.

### Системы

*Система сущностей* (часто сокращённо "система") содержит логику, реализующую поведение для конкретных компонентов. Например, в игре может быть несколько сущностей с `NukeComponent`, но только одна система `NukeSystem`, которая обрабатывает все такие сущности.

Системы сущностей реализуют поведение через определение *обработчиков событий* или методом *обновления* для каждого тика.

Пример: `FoodComponent` и система `EatingSystem`, которая отвечает за поедание пищи. Когда событие `OnUseInHand` срабатывает, `EatingSystem` проверяет наличие компонента `FoodComponent` в объекте, который был использован. Если компонент есть, система уменьшает значение `nutritionLeft` и проигрывает звук поедания.

Это основные принципы ECS. Если хотите узнать больше, загляните в [Your mind on ECS](../robust-toolbox/ecs.md). Архитектура ECS действительно мощна и помогает избегать "спагетти-кода", несмотря на сложность SS14.

```admonish info
Не обязательно сразу досконально понять архитектуру ECS. Это может быть сложно как для новичков, так и для опытных программистов. Однако по мере использования этой архитектуры её преимущества станут очевидны.
```

## Как создать сущность и добавить к ней компоненты?

SS14 использует систему **прототипов**. Это своего рода "заготовки сущностей". Они похожи на *префабы* в Unity или подтипы `/obj` или `/mob` в BYOND.

Прототипы сущностей определяют, *какие компоненты есть у сущности и какие данные они хранят*. Также они задают основные данные, такие как имя сущности, описание и её ID (для создания в игре).

Пример:

```yaml
- type: entity
  parent: BaseItem
  id: Skub
  name: skub
  description: Skub is the fifth Chaos God.
  components:
  - type: Sprite
    sprite: Objects/Misc/skub.rsi
    state: icon
  - type: Item
  - type: ItemCooldown
  - type: EmitSoundOnUse
    sound: /Audio/Items/skub.ogg
  - type: UseDelay
    delay: 2.0
```

Этот код написан на **YAML**, языке данных, похожем на JSON, и находится в папке `Resources/Prototypes/Entities/Objects/Fun/skub.yml`. Все прототипы должны быть в папке `Resources/Prototypes` и правильно организованы по каталогам.

Если вам нужно больше информации по YAML, посмотрите [YAML Crash Course](../general-development/tips/yaml-crash-course.md) и [Serialization](../robust-toolbox/serialization.md).

Прототип сущности "Skub" в игре выглядит так:

![](https://i.imgur.com/qOJ5OyB.png)

Как видно, он содержит несколько компонентов, включая `EmitSoundOnUse` и `ItemCooldown`. Разработчики решают, какие данные хранят компоненты и как системы придают им поведение.

Чтобы создать предмет в игре через прототип, нажмите **F5**, чтобы открыть **панель создания сущностей**. Также можно создавать прототипы в коде.

## Как сделать гудок?

Ваша цель — создать **клоунский гудок**, который **издаёт звук** при использовании. Для этого нам нужно добавить компонент, хранящий звук, и систему, которая воспроизведёт его при активации гудка.

```admonish info
Обычно стоит проверить кодовую базу и спросить других разработчиков, существует ли уже компонент или система для этой задачи. В данном случае компонент ```EmitSoundOnUse``` *уже существует*, но для учебных целей мы создадим его с нуля!
```

### Создание прототипа

Создайте новый файл ```clown_horn.yml``` в папке `Resources\Prototypes\Entities\Objects`.

```yaml
- type: entity
  name: clown horn
  parent: BaseItem
  id: ClownHorn
  description: It goes honk honk!
  components:
  - type: Sprite
    sprite: Objects/Fun/bikehorn.rsi
    state: icon
```

Этот прототип задаёт сущность с компонентом `SpriteComponent`. 

Теперь давайте добавим компонент, который будет воспроизводить звук при использовании, и создадим систему для обработки этого действия.

Следует отметить, что прототипы поддерживают Parenting. В данном случае `BaseItem` является нашим родителем и содержит множество компонентов, которые являются универсальными для всех предметов. Таким образом, наш клоунский рог тоже будет содержать эти компоненты: базовые компоненты, такие как `Item`, `Pullable` и `Physics`. Родители вовсе не обязательны, но они полезны в некоторых случаях, как, например, здесь.

Теперь давайте скомпилируем и проверим наш предмет в игре:

![](https://i.imgur.com/dHigBbc.png)

Она, конечно, прекрасна, но, похоже, мы обманулись! Велосипедный клаксон пока не делает хонк хонк, клоун нас убьёт! Чтобы исправить это, нам придётся создать новый компонент для хранения данных, таких как звук, который нужно воспроизвести, и EntitySystem, которая будет управлять воспроизведением звука.

## Создание нашего компонента

Чтобы создать наш компонент, нам нужно создать новый класс, назовём его ``PlaySoundOnUseComponent``. Но подождите секунду....

![](https://i.imgur.com/s9O13qH.png)

Куда мы его поместим? Чтобы ответить на этот вопрос, мы должны мыслить широко. Мы должны думать о **клиенте** и **сервере**.  

### Парадигма клиент-сервер

Если вы ещё не читали [Codebase Organization](../general-development/codebase-info/codebase-organization.md), то, возможно, стоит ознакомиться. Но для этого урока вам нужно понять только две вещи:

- СЕРВЕР и КЛИЕНТ выполняются РАЗДЕЛЬНО.
- Сервер должен обрабатывать большую часть логики, чтобы предотвратить эксплойты. Все, что находится на клиенте, может быть изменено злоумышленником.

Исходя из этого, наша логика для клоунского гудка должна выглядеть следующим образом:

- Клиент отправляет на сервер сообщение «Я использую этот предмет».
- Сервер получает это сообщение, проверяет, имеет ли оно смысл, и отправляет «play honk» всем клиентам в радиусе действия.
- Клиент получает это и производит «гудок».

Это звучит довольно сложно для реализации с нуля. К счастью, у нас есть готовый код, который поможет нам! А именно, событие `UseInHandEvent`, которое поднимается на сервере, когда предмет используется, и функция `SoundSystem.Play()`, которая воспроизводит звук для клиентов в радиусе действия.

Можно считать, что эти помощники обрабатывают **клиентский клик -> сервер** и **сервер -> клиентский звук** за нас. Так что все, что нам нужно сделать, это иметь компонент на сервере, который направляет одно в другое. 

### Базовое создание компонента

```admonish warning
В кодовой базе Space Station 14 компоненты и EntitySystems (а также другие классы) находятся в папках, расположенных непосредственно под проектами `Content.Server`, `Content.Shared` или `Content.Client`. Есть папки для `Atmos`, `Botany`, `Research`, `Storage` и многие другие. Если подходящей папки не существует, создайте её! Никогда не помещайте файлы непосредственно в основную директорию проекта.
```

В проекте `Content.Server` есть папка `Sound`. Кажется, что это хорошее место для размещения нашего нового компонента (и на самом деле, именно здесь находится настоящий EmitSoundOnUse). Назовём нашу версию `PlaySoundOnUseComponent`. Примечание: если вы просто вставите этот код, он может не работать, так как вам придётся импортировать различные классы. Ваша IDE может сделать это за вас.

Теперь давайте сделаем самый простой компонент:

```csharp
// Content.Server/Sound/PlaySoundOnUseComponent.cs

namespace Content.Server.Sound;

[RegisterComponent]
public sealed partial class PlaySoundOnUseComponent : Component
{
}
```

Все компоненты должны наследоваться от класса `Component`. Если вы хотите, чтобы ваш компонент читался в YAML, вам придётся добавить `[RegisterComponent]` над вашим классом. Кроме того, все компоненты должны быть помечены `sealed` и `partial` по причинам, связанным с движком. Вам не нужно слишком беспокоиться о том, что они означают.

В нашем прототипе выше вы можете вспомнить, что мы добавили `Sprite`, а не `SpriteComponent` к прототипу ClownHorn. Это потому, что «имена» компонентов генерируются автоматически, используя имя класса. В данном случае имя нашего компонента - `PlaySoundOnUse`, которое генерируется путём удаления `Component` из имени класса.

Теперь давайте продолжим и добавим PlaySoundOnUse в наш прототип.

```yaml
- type: entity
  name: clown horn
  parent: BaseItem
  id: ClownHorn
  description: It goes honk honk!
  components:
  - type: Sprite
    sprite: Objects/Fun/bikehorn.rsi
    state: icon
  - type: PlaySoundOnUse
```

Это скучно: у нашего компонента не только нет данных, но и он ничего не делает!

Давайте добавим некоторые данные в наш компонент. Как вы могли заметить выше, компонент `Sprite` на нашем велосипедном рожке имеет два поля: `sprite` и `state`. Все, что вы поместите в эти поля, будет передано в компонент при его создании, а затем наша система сущностей (EntitySystem) сможет использовать эти данные для выполнения каких-либо действий.

В нашем случае мы, вероятно, захотим, чтобы в компоненте было поле под названием `Sound`, в котором будет храниться путь к звуку, воспроизводимому при активации сущности. Сделать это довольно просто:

```csharp
// Content.Server/Sound/PlaySoundOnUseComponent.cs

namespace Content.Server.Sound;

[RegisterComponent]
public sealed partial class PlaySoundOnUseComponent : Component
{
    [DataField]
    public string Sound = string.Empty;
}
```

Чтобы создать поле, которое можно изменять в YAML, достаточно добавить атрибут `[DataField]`, который содержит имя поля, и присвоить ему значение по умолчанию, в данном случае `string.Empty`. Теперь мы можем добавить наш звук в прототип велосипедного клаксона:

```yaml
- type: entity
  name: clown horn
  parent: BaseItem
  id: ClownHorn
  description: It goes honk honk!
  components:
  - type: Sprite
    sprite: Objects/Fun/bikehorn.rsi
    state: icon
  - type: PlaySoundOnUse
    sound: /Audio/Items/bikehorn.ogg
```

Теперь у нас что-то получается! Обратите внимание, что путь здесь указан относительно директории `Resources` (что `SoundSystem` всегда предполагает), и мы также предполагаем, что файл `Resources/Audio/Items/bikehorn.ogg` является реальным. Если проверить, то так оно и есть! Но если нужного вам звука нет, вы всегда можете добавить его самостоятельно в папку `Audio`.


## Создание нашей EntitySystem

Давайте, наконец, добавим изюминку нашему велосипедному клаксону, заставив его на самом деле хонкать. Как уже говорилось, нам понадобится `EntitySystem`, которая подключается к `UseInHandEvent` и вызывает оттуда некоторый код. Давайте создадим нашу систему сущностей `PlaySoundOnUseSystem` в той же папке `Content.Server/Sound`:

```csharp
// Content.Server/Sound/PlaySoundOnUseSystem.cs

namespace Content.Server.Sound;
    
public sealed class PlaySoundOnUseSystem : EntitySystem
{

}
```

Вы заметите, что здесь наша система наследует от `EntitySystem`. Это автоматически регистрирует её как правильную EntitySystem в игре и позволяет нам использовать некоторые полезные зависимости и переопределять некоторые методы, чтобы добавить поведение.

Для того чтобы подписаться на событие, нам нужно переопределить метод `Initialize` системы; этот метод вызывается при создании EntitySystem.

В этом методе мы добавим вызов `SubscribeLocalEvent`, а подробности я объясню после.

```csharp
// Content.Server/Sound/PlaySoundOnUseSystem.cs

namespace Content.Server.Sound;

public sealed class PlaySoundOnUseSystem : EntitySystem
{
    public override void Initialize()
    {
        SubscribeLocalEvent<PlaySoundOnUseComponent, UseInHandEvent>(OnUseInHand);
    }
}
```

В этом вызове метода происходит очень многое! По сути, мы говорим игре:

*"Всякий раз, когда на сущность, имеющую компонент PlaySoundOnUse, поднимается событие UseInHandEvent, я хочу, чтобы вы вызвали мой метод OnUseInHand. »*.

Вы, наверное, заметили, что этот код на самом деле выдаёт ошибку, потому что метода OnUseInHand ещё не существует! Давайте добавим этот метод. Это называется **обработчиком событий**, а обработчики событий требуют определённого набора аргументов:

- UID (уникальный идентификатор) сущности, для которой было вызвано событие
- компонент, который был указан в подписке, чтобы вы могли получить доступ к его данным и использовать их для изменения поведения
- Само событие, которое содержит полезные данные, такие как сущность, активировавшая элемент.

Если вы используете IDE, она может позволить вам автоматически создать этот метод с помощью *Alt+Enter*.

Вот как теперь будет выглядеть наш класс с новым методом:

```csharp
namespace Content.Server.Sound;

public sealed class PlaySoundOnUseSystem : EntitySystem
{
    [Dependency] private readonly SharedAudioSystem _audio = default!;
    
    public override void Initialize()
    {
        SubscribeLocalEvent<PlaySoundOnUseComponent, UseInHandEvent>(OnUseInHand);
    }

    private void OnUseInHand(Entity<PlaySoundOnUseComponent> ent, ref UseInHandEvent args)
    {

    }
}

```

Мы почти у цели. Теперь при активации предмета будет вызываться метод `OnUseInHand`, и мы сможем воспроизвести наш звук там.

Также мы добавили в класс `[Dependency] private readonly SharedAudioSystem`. Это позволит нам в дальнейшем воспроизводить аудио современным способом (вместо использования устаревшего `SoundSystem.Play`).

```csharp
private void OnUseInHand(Entity<PlaySoundOnUseComponent> ent, ref UseInHandEvent args)
{
    _audio.PlayPvs(ent.Comp.Sound, ent.Owner);
}
```

Метод `PlayPvs` полезен для воспроизведения звуков. Он имеет два аргумента:

1. Звук, который нужно воспроизвести.

В данном случае мы просто передаём ему наше поле `Sound` в `PlaySoundOnUseComponent`. 

2. Сущность-источник 

Это необязательный аргумент, который используется для позиционного звука. В нашем случае мы хотим, чтобы звук исходил от рога, поэтому мы передаём Uid рога (который является свойством `Owner` сущности). Если этот параметр не указан, звук будет воспроизводиться глобально и будет слышен всем игрокам.

Если вы скомпилируете игру и спауните наш велосипедный клаксон с помощью меню **F5** Entity Spawn Menu, вы можете попробовать активировать его в руках и - невероятно! Он воспроизводит звук правильно! Надеюсь! Если нет, возможно, вы что-то напутали в YAML или пропустили метод в EntitySystem.

Кроме того, `PlayPvs` автоматически управляет фильтрацией расстояний, так что вам не придётся об этом беспокоиться.

## Мы закончили.

На этом мы закончили этот урок! Если вы хотите продолжить эксперименты с обретённым клоунским гудком, вот несколько идей:

- Попробуйте реализовать клоунский рог, используя существующие компоненты. Вы можете обратиться к skub.yml на этой странице.
- Добавьте задержку на нажатие, добавив ``ItemCooldown`` к вашему прототипу и подняв ``RefreshItemCooldownEvent``.
- Настройте громкость/изменение воспроизводимого звука (см. аргумент `PlayPvs()` функции `audioParams`).
- Сделайте так, чтобы звук воспроизводился и при нажатии на клаксон велосипеда.
    - Это довольно сложно и требует добавления большого количества новых данных! Для примера посмотрите на осколки стекла.
- Заставьте велосипедный клаксон наносить урон при атаке с помощью MeleeWeaponComponent.
- Сделайте велосипедный рожок съедобным с помощью FoodComponent и SolutionContainerComponent.
- Добавьте поддержку воспроизведения случайного звука из SoundCollection или SoundSpecifier, а не одного звука (это делает настоящий EmitSoundOnUse, если вам нужны указатели). 
- Погрузитесь в код взрыва и дайте ему 5% шанс взорваться при каждом гудке!

Мир - это ваш пакет с донк-покетами, и у вас есть обжигающе горячий огонь, чтобы приготовить его!