```admonish warning "В процессе"
Эта страница находится в стадии разработки! Некоторая информация может быть неполной или неактуальной.
```

# Git для разработчика СС14

Если вы когда-нибудь смотрели халтурно написанное руководство по Git'у или открывали один из множества невероятно раздутых современных графических интерфейсов git'а, таких как GitKraken, вы, вероятно, понимаете, что Git может быть *очень запутанным*. Цель этого руководства - дать вам только ту информацию, которая необходима для правильной разработки для SS14, и предоставить вам ресурсы, чтобы узнать больше, если это необходимо.

Здесь немного ресурсов для изучения гита:
- [Онлайн книга от разработчиков Гита](https://git-scm.com/book/ru/v2), очень полезная вещь для начинающих, которая может помочь новичкам.
- [Руководство по Git от Atlassian](https://www.atlassian.com/git/tutorials/setting-up-a-repository). Хорошие гайды для более продвинутых пользователей
- [Ёбанный Git!!!](https://ohshitgit.com/ru), список решений распространенных проблем с git в веселом формате. Может пригодиться.
- [Learn Git Branching](https://learngitbranching.js.org/?locale=ru_RU). Этот курс интерактивный и очень подробный, к его концу вы **выучите Git**. Рекомендуется, если вы уже не новичок но и не профи в Git.

## 1. Настройка самого Гита

```admonish danger "НЕ ИСПОЛЬЗУЙТЕ GITKRAKEN"
Ради всех богов, хостов и сисадминов, не устанавливайте GitKraken или GitHub Desktop. Я не испытывал ничего, кроме бесконечной боли, пытаясь помочь людям, использующим их. Я знаю, что GitKraken выглядит профессионально, а GH Desktop - красиво и просто, но, пожалуйста, не используйте их, если вы не знаете, что делаете.
```

Если вы следовали нашему руководству по **настройке среды разработки**, то, вероятно, у вас уже установлен Git. Если нет, перейдите на [их сайт](https://git-scm.org) и установите его прямо сейчас. Это позволит установить сам Git, а также Git Bash (если вы выберете эту опцию) - один из многих способов использования Git. 

Если вы работаете на Линуксе, то, скорее всего, будете использовать Git через терминал или выбранную вами IDE, и, скорее всего, он у вас уже установлен.

Я настоятельно рекомендую хотя бы попробовать Git Bash, но есть и более дружелюбные альтернативы, которые я также покажу здесь:

- [TortoiseGit](https://tortoisegit.org/) -- старый, но хороший графический визуализатор Git, который отображает информацию в проводнике и делает базовые вещи более простыми.
- [SmartGit](https://www.syntevo.com/smartgit/) -- полнофункциональный графический интерфейс Git, хорошо настраиваемый и простой в использовании.

После того как я написал этот гайд я попробовал еще пару вариантов, и среди них есть и другие очень, очень хорошие программы:

- [Fork](https://git-fork.com/) -- быстрый и чрезвычайно эргономичный графический интерфейс, мой личный фаворит. «Платная», но она такая же „небесплатная“ как WinRAR, так что по сути она бесплатная.
- [Sublime Merge](https://www.sublimemerge.com/) -- очень похож на Fork, выглядит и ощущается отлично, и я получал много рекомендаций по его использованию, хотя и не использовал его так много.

Большинство IDE имеют ту или иную форму интеграции с Git. Интеграция Гита [JetBrains Rider](https://www.jetbrains.com/rider/) действительно хороша (и я лично рекомендую Rider для всего, что связано с разработкой в 14 станции). Я не рекомендую Git в Visual Studio, потому что он... не особо хорош

Пока вы здесь, установите `Python 3.7+`, если у вас его еще нет. Вы можете сделать это [здесь](https://www.python.org/) для Windows и Mac, а если вы на Linux, то у вас почти наверняка уже установлен Python. Если нет, разберись сам, тупой придурок.

<hr>

```admonish danger "Сохранность Email и Имени"
Когда вы [настраиваете свои `user.name` и `user.email`](https://git-scm.com/book/ru/v2/Getting-Started-First-Time-Git-Setup#_your_identity), знайте, что они будут публично отображаться во всех создаваемых вами коммитах. Если вы хотите сохранить конфиденциальность своей информации, вы можете установить `user.name` на ваше имя пользователя вместо вашего настоящего имени, а `user.email` на тот, который предоставляет GitHub, когда в [GitHub Email Settings](https://github.com/settings/emails#primary_email_select_label) установлен флажок [`Keep my email addresses private`](https://github.com/settings/emails#toggle_visibility).
```

Теперь, когда у вас установлен Git, я рекомендую вам сначала немного почитать о его основах и познакомиться с любым git-клиентом, с которым вы работаете, будь то командная строка (Git Bash) или что-то другое.

Мы рассмотрим процесс создания окружения Git для Space Station 14, чтобы вы могли **внести свой вклад в проект через Pull Request, создать собственную кодовую базу** или просто **посмотреть историю развития проекта**.

### 1.1 Почему мы вообще используем Git?

Git - это **программа контроля версий**. По сути, это простой способ отслеживать изменения в коде и управлять этими изменениями без головной боли. Это бесценный инструмент для разработки программного обеспечения, потому что он позволяет легко вносить новые изменения, просматривать различные изменения, видеть, кто внес изменения, и т. д. без необходимости координировать и табулировать все самостоятельно.

GitHub - это онлайн-сервис, на котором размещаются Git **репозитории** (кодовые базы) для удобства совместной работы. Он идеально подходит для такой кодовой базы, как SS14, с большим количеством участников и большой историей. Это также означает, что у нас *открытый код* - любой может зайти на наш GitHub и скачать его!

## 2. Настройка репозитория

Как я уже говорил, репозиторий - это просто кодовая база. Репозитории содержат несколько **ветвей**, а эти ветви содержат различные **коммиты**. Вы, возможно, слышали об этих двух понятиях - я расскажу о них подробнее позже.

**Удалённый** репозиторий - это просто репозиторий, который находится на серверах GitHub. То что он называется удалённым не означает что его выкинули! **Локальный** репозиторий - это тот, который находится на вашем компьютере.

### 2.1 Создание своего удалённого репозитория

Во-первых, давайте создадим наш собственный удаленный репозиторий Space Station 14. Для этого, конечно, вам понадобится учетная запись на GitHub. "Форк"(Fork) таким образом просто означает, что вы копируете всю историю репозитория и изменения в свой собственный удаленный репозиторий, чтобы вы могли свободно вносить изменения в код.

Ваш удаленный репозиторий не будет автоматически синхронизироваться с изменениями из оригинального репозитория SS14 - вам придется делать это самостоятельно, а как это делать я расскажу чуть позже.

Перейдите в [репозиторий Space Station 14](https://github.com/space-wizards/space-station-14) и нажмите на кнопку «Fork», которая помечена на скриншоте:
![](https://i.imgur.com/lAHNHdD.png)

Там вас спросят, где сделать форк и как его назвать - просто зайдите в свой обычный аккаунт и назовите его как угодно! Я бы выбрал `space-station-14`, если вы просто хотите помочь в разработке.

### 2.2 Создание своего локального репозитория

Теперь нам нужно загрузить наш удаленный репозиторий на наш компьютер (это называется **клонирование**), чтобы мы могли добавить ~~20 пар клоунских ботинок в каждый шкафчик~~ некоторые изменения в нем. Технически вы *можете* изменить удаленный репозиторий (на GitHub есть несколько хороших инструментов), но наличие его на вашем компьютере означает, что вы используете IDE вроде Visual Studio или Rider для сборки игры и запуска тестов, а также для удобной работы с Git.
Для каждого шага будут приведены скриншоты и инструкции для Git Bash, SmartGit и TortoiseGit под Windows.

Перейдите в то место на вашем компьютере, где вы хотите разместить локальный репозиторий, и:
<details><summary>TortoiseGit</summary>
<p>

Щелкните правой кнопкой мыши, чтобы увидеть контекстное меню TortoiseGit:

![](https://i.imgur.com/QGmrQmH.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

Откройте SmartGit и перейдите в нужное место, затем:

![](https://i.imgur.com/C3JBYR6.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

Щелкните правой кнопкой мыши:

![](https://i.imgur.com/kIYnm16.png)

</p>
</details>

<hr>

Затем мы введем команду для клонирования **нашего** удалённого репозитория - не репозитория `space-wizards/space-station-14`.
<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/3HzCnjm.png)
![](https://i.imgur.com/a7vhKcC.png)


</p>
</details>  

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/YyJm5fx.png)


</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/Xn4AQLf.png)

Затем переключитесь на папку вашего репозитория, используя:
``cd space-station-14`` 

(Название папки может отличаться, если вы клонировали другой репозиторий, но оно почти всегда совпадает с именем репозитория)

Каждая команда в Git выглядит примерно так - `git` и затем ключевое слово `add`, `commit`, `pull` и т.д.

</p>
</details>

<hr>

После этого у вас будет локальный репозиторий, который теперь можно изменять! Однако вам еще предстоит выполнить некоторые настройки.

### 2.3 Боль с сабмодулями

**Обратите на это внимание!** Если вы не сделаете этого, то при попытке скомпилировать игру вы получите множество странных ошибок.

В Space Station 14 есть *множество* субмодулей - в первую очередь, наш движок RobustToolbox. Субмодули - это просто репозитории внутри репозитория, и их нужно обновлять вручную. Или нет?

У нас есть автоматическая программа обновления подмодулей, так что вам не нужно постоянно запускать `git submodule update --init --recursive` (команда для ручного обновления подмодулей).

Запустите `RUN_THIS.py` внутри репозитория, который вы скачали, с помощью Python(ВЫ же установили Python как я просил в начале этого гайда?). Желательно также из терминала введите `python RUN_THIS.py` или `python3 RUN_THIS.py`. Это должно занять несколько секунд, так что если все мгновенно прекратится, вы, вероятно, не используете Python 3.7+ или что-то в этом роде.

Если вы работаете под Windows и при попытке выполнить приведенную выше комбинацию действий получаете перенаправление в Microsoft Store или сообщение в терминале о том, что Python не установлен, вам нужно отключить ярлык Microsoft, который может вызывать эту проблему. Это можно сделать, найдя в поиске Windows пункт `Manage App Execution Aliases` и отключив две ссылки Python.

Если вы все же хотите модифицировать движок напрямую или обновлять субмодуль вручную (автообновление иногда доставляет неудобства), создайте файл DISABLE_SUBMODULE_AUTOUPDATE в директории BuildChecker/.

Если вам по какой-то причине понадобится вручную обновить RobustToolbox, вы можете использовать `cd RobustToolbox; git checkout v0.4.87` (замените `v0.4.87` на нужную вам версию RobustToolbox), а затем вы можете использовать `cd..\`, чтобы вернуться в репозиторий SS14. Это также пример использования `cd` для навигации по файлам, не выходя из командной строки.

## 3. Настройка удалённых репозиториев
Когда вы клонировали удалённый репозиторий, в ваш локальный репозиторий автоматически был добавлен **ремоут**. **Ремоуты** - это именованные URL-адреса удалённых репозиториев, которые Git отслеживает, чтобы вы могли делать такие вещи, как скачивать (pull) новые изменения в коде или загружать (push) код в ваш форкнутый репозиторий. 

В этом случае автоматически добавляемый удалённый репозиторий называется `origin` и указывает на `https://github.com/[имя пользователя-здесь]/space-station-14` (или как вы назвали удаленное хранилище).

Одна проблема: у нас нигде нет ссылки на оригинальный удаленный репозиторий `space-wizards/space-station-14`! Как же мы сможем обновить наш локальный репозиторий без неё? Поэтому давайте убедимся, что мы перешли в папку нашего локального репозитория, и добавим новый ремоут:

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/yANaYWI.png)
![](https://i.imgur.com/cjbhMEN.png)


</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/LXCpgVo.png)
![](https://i.imgur.com/ZHIHPJC.png)


</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/00ETpii.png)

</p>
</details>

<hr>

Все, что это делает, - добавляет новый удаленый репозиторий с именем `upstream`, который указывает на исходный репозиторий `space-wizards/space-station-14`. Теперь мы можем получать обновления из основного репозитория, когда захотим! (о том, как это сделать, читайте ниже). 

Принято называть удалённый репозиторий, указывающий на исходный репозиторий, как `upstream`, но технически вы можете называть его как угодно. Однако я буду ссылаться на него как на «upstream», и это терминология, которую также используют руководства Git.

**Дополнение для разработчиков форков:** Если репозиторий, в который вы хотите внести вклад, настроен как прямой форк (то есть: GitHub показывает метку «forked from» под именем репозитория), то вам дополнительно нужно добавить этот форк в качестве удаленного (но если форк не настроен таким образом, вы можете проигнорировать это). Вы можете сделать это аналогично тому, как вы добавили upstream в качестве remote (просто используйте ссылку на GitHub форка в качестве URL remote), но не забудьте заменить имя remote `upstream` на любое имя, которое вы считаете подходящим. Для этого ваш собственный форк не обязательно должен быть форком форка; важно лишь, чтобы история коммитов в отдельных ветках, которые вы отправляете на свой собственный удалённый ресурс, совпадала с историей коммитов того, куда вы собираетесь добавлять свои изменения.

```admonish warning title="Перед тем как приступить к работе над своим первым PR в репозитории space-wizards"
Убедитесь, что вы прочитали [Freezes & Restrictions](https://github.com/space-wizards/space-station-14/issues/8524) и удостоверились, что ваша идея не попадает под заморозку, или что для вашего PR требуется какое-то предварительное условие. 
```

## 4. Ветвление и коммиты

Ветви и коммиты - две самые важные концепции в Git, и большая часть вашей работы будет вращаться вокруг них.

### 4.1 Что такое этот ваш коммит?


Как я уже говорил, **коммиты** - это просто упакованные изменения в коде. Как разработчик, вы выбираете, какие изменения войдут в коммит и когда их фиксировать.

Коммиты имеют автора, временную метку создания, сообщение и некоторые изменения кода. У них также есть длинный «хэш коммита», уникальный идентификатор, используемый для ссылки на разные коммиты.

Коммиты - это то, как строится история. Вы можете просмотреть историю каждого коммита, сделанного в репозитории SS14 с самого начала, что очень здорово:

![](https://i.imgur.com/HQDdw6h.png)

(выполняется с помощью `git log --reverse`)

### 4.2 Что такое это ваша ветка(бранч)?

**Ветки** очень, очень важны. По сути, это просто список изменений в коде (коммитов). По умолчанию используется ветка 'master', и все наши серверы используют эту ветку для компиляции кода. 

Вы практически всегда находитесь "в ветке", когда работаете с кодом, и вы можете легко переключать ветку, в которой работаете.
Как правило, ветки называются по имени того, над чем вы собираетесь в них работать, но на самом деле не имеет значения, как они называются.

Вы можете создавать столько веток, сколько захотите. Когда вы создаете ветку, она «отходит»  (нифига себе, правда?) от текущей ветки, на которой вы находитесь, и становится полностью независимой, после чего вы можете добавлять коммиты.

![](https://i.imgur.com/ByMugxu.png=500x300)

На этой диаграмме каждый маленький узел - это отдельный коммит, а каждый цвет - отдельная ветвь.

#### Объединение веток

Ветви важны, потому что они могут быть **слиты** вместе. Процесс слияния также называется мердж (от англ. merge). Именно так функции интегрируются в основную ветку `master`. **Слияние** означает «взять коммиты с новыми изменениями кода из этой ветки и применить их к другой ветке с другой версией кода».  Вы можете объединить две любые ветки.

Иногда это не проходит гладко, потому что обе ветки изменяют одну и ту же часть файла противоречивыми способами, и в этом случае вы получите **мердж конфликт** - подробнее об этом в дополнениях.

Pull Requests(в русском сообществе их обычно называют ПРы) от GitHub на самом деле является «запросом на мердж» - вы говорите, что хотите объединить коммиты в вашей ветке с другой веткой, обычно `master`. Подробнее об этом позже.
ПРы очень хорошо отображают всю эту информацию:

![](https://i.imgur.com/YAOWX5R.png)
![](https://i.imgur.com/nWWy3J4.png)

В этом пулл реквесте Swept начал с создания новой ветки. Поскольку теперь у него была свежая ветка, свободная от помех, он начал работать над функцией и создавал коммиты для «сохранения прогресса», когда считал это необходимым. Эти коммиты добавлялись в ветку последовательно, и вы можете видеть эволюцию ветки по мере написания кода. Подробнее о запросах на исправление мы поговорим позже.

#### Но почему я должен это все делать?

Технически, конечно, вы можете просто сделать всю свою работу в ветке `master` и отправлять запросы оттуда. Но создание разных веток позволяет легко понять, где вы находитесь, сколько изменений вы внесли, и дает возможность работать над несколькими функциями одновременно.

Также мы закроем ваш PR, если он будет из вашей ветки `master` (это может легко привести к проблемам), так что не делайте этого.

### 4.3 Создание и работа с ветками

Создавать ветки довольно просто. Давайте создадим новую ветку под названием `smeshnoye-izmenenie`:

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/OGkblCk.png)
![](https://i.imgur.com/ZPfzFcm.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/pK1oyfz.png)
![](https://i.imgur.com/5MZ6Ocv.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/kOc9rfe.png)

Вы можете заметить, что название в скобках (master) изменился на (funny-feature)! Невероятно!

`-b` в `git checkout` здесь означает «проверить эту ветку, и создать её, если она не существует».

</p>
</details>

<hr>

Теперь вы можете свободно работать с этой веткой по своему усмотрению, не боясь испортить важную мастер-ветку.

Переключаться между ветками довольно просто: когда вы это делаете, ваши локальные файлы и папки будут изменены в соответствии с веткой, поэтому Git будет кричать на вас, если у вас есть локальные изменения, а вы пытаетесь сменить ветку.

Меняем ветку:

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/UThKrCK.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/fzC1pVm.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/DqWEdY5.png)

</p>
</details>

<hr>

Затем внесите любые локальные изменения! Это не имеет значения. Создайте новый файл, удалите всё, измените одну строку в файле и т. д. Это не повлияет на вашу `master` ветку, потому что теперь вы находитесь на ветке `funny-feature`!

### 4.4 Внесение и сохранение изменений в вашей ветке

И еще один важный момент: прежде чем `коммитить` свои изменения, вы должны `добавить` их в **staging**. Это означает, что вы указываете, какие файлы вы хотите коммитнуть. Это полезно, потому что вы *почти никогда* не захотите коммитить изменения сабмодулей, поэтому вы избежите этого, не добавляя их в staging. 

Как уже говорилось, коммиты всегда сопровождаются сообщением, которое представляет собой краткое, императивное описание того, что было сделано в этом коммите. Или вы можете быть чадом и называть каждый коммит «123», решать вам.

Если вы хотите посмотреть, что вы изменили в данный момент и что находится в staging, это довольно просто:

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/xmZKKWJ.png)

TortoiseGit также показывает измененные файлы/папки (красный значок в правом нижнем углу) в проводнике Windows, что очень приятно и это почему я установил его в первую очередь.

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/ROsurs1.png)

Это при условии, что вы установили SmartGit с опцией, при которой в главном окне отображаются диффы и статус. Если вы этого не сделали, я не знаю, где это находится.

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/UeMjAHj.png)

</p>
</details>

<hr>

Теперь, когда вы убедились, что все эти изменения выглядят хорошо, мы добавим их в staging и коммитнем (некоторые графические интерфейсы Git делают это в один шаг).

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/ltIASro.png)
![](https://i.imgur.com/BIa9r6c.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/RYUL7u3.png)
![](https://i.imgur.com/Du7HqRV.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/mpKk5L1.png)

</p>
</details>

<hr>

Ух ты, мы зафиксировали наши изменения в ветке! Теперь, когда они зафиксированы, они навсегда остаются в истории ветки (вроде как). Теперь мы можем сделать множество вещей: мерджнуть нашу `funny-feature` в нашу локальную ветку `master` (если мы хотим, по какой-то причине), загрузить (push) нашу ветку `funny-feature` в наш удалённый репозиторий или полностью удалить ветку (среди прочего). Сейчас мы выберем push и сделаем pull request.

## 5. Делаем Pull Request

**Pull request** - это специфическая для GitHub вещь. Он означает, что вы хотите, чтобы кодовая база объединила ваши изменения в одной из ваших веток в одну из xe;b[] веток - как правило, в свою `master` ветку. Прежде чем мы сможем это сделать, наш удаленный репозиторий GitHub (origin) должен знать о красивых ветках и коммитах, которые мы создали локально, поэтому мы загружаем или **пушим**(push, толкаем) эти изменения на удаленный репозиторий.

### 5.1 Пушим коммиты

Теперь, когда мы коммитнули наши изменения, их очень просто пушнуть. Имейте в виду, что при использовании этих команд Git, вероятно, запросит ваши учетные данные GitHub, чтобы убедиться, что вам разрешено отправлять изменения на этот ремоут.

При пуше изменений мы указываем *удаленный* репозиторий, в который мы отправляем изменения, и *локальную* ветку, в которую мы отправляем изменения. Достаточно просто.

Пушим нашу ветку в удаленный репозиторий (origin):

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/bWS5Kdk.png)
![](https://i.imgur.com/Irv1e5k.png)

 «Push all branches» делает то, что написано в его названии. Может быть полезным.

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/s82VnNn.png)
![](https://i.imgur.com/VP8PuCq.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/7FJqzkL.png)

</p>
</details>

### 5.2 Создание Pull Request'а

А теперь самое интересное. Сейчас мы пойдем на GitHub и сделаем pull request для нашей забавной функции.

![](https://i.imgur.com/YNmEMtG.png)

Добавьте описание, красивое название, несколько скриншотов, и, надейтесь, что он будет мерджнут.

## 6. Обновляем наш репозиторий

Возможно, прошло уже много времени, неделя или две, с момента вашего последнего ПРа, и вы хотите сделать еще один. Прежде чем что-то делать, вам нужно загрузить (**pull**) изменения кода из основного репозитория SS14 в свой локальный репозиторий. Если вы этого не сделаете, у вас будет устаревший код, а ваши локальные изменения могут не соответствовать тому, как игра будет работать на самом деле - вы даже можете получить **мердж конфликт**, когда попытаетесь сделать ПР.

Существует два способа обновления репозитория. Оба способа предполагают, что вы правильно настроили удаленный `upstream` - если это не так, вернитесь к предыдущему пункту руководства. И, конечно, если вы разрабатываете для форка, то вам нужно заменить `upstream` на то, как вы назвали репозиторий downstream в шаге 4, чтобы убедиться, что вы работаете с файлами downstream, а не upstream. Убедитесь, что вы *всегда* проходите процесс обновления при переключении между вкладом в форк и вкладом в upstream, иначе вы неизбежно окажетесь либо в PR всей истории downstream в upstream, либо сделаете PR в downstream, которые немедленно вступят в конфликт.

Первый метод, **fetch+merge**, дает вам больше контроля, но может быть запутанным. Второй метод, **pull**, прост и легок, но не дает вам большого контроля. Однако, как правило, pull - это все, что вам нужно.

### 6.1 Метод fetch + merge

**Fetching** означает загрузку новых веток и коммитов из удалённого репозитория, но пока ничего с ними не делаем (локально ничего не изменится). После получения изменений из удаленного `upstream` (основного репозитория SS14) мы объединим их с нашей локальной веткой `master`.

Когда вы качаете удалённый репозиторий, он загружает эти ветки в ваш локальный репозиторий и добавляет к ним имя удалённой ветки и слеш. Таким образом, когда вы получаете `upstream`, он создаст ветку под названием `upstream/master`. В качестве бонуса вы можете проверить эту удаленную ветку напрямую, если захотите, и даже создать на ее основе локальную ветку, что особенно полезно, если вы работаете не только с upstream.

Сначала давайте фетчнем `upstream`. Это займет немного времени.

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/3cWun8b.png)
![](https://i.imgur.com/XGgXRY0.png)

Убедитесь, что вы выбрали `upstream`, а не origin!

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/CNFFJJ8.png)

Я думаю, что smartgit берет данные со всех ремоутов, когда вы нажимаете вот это?????.

Если это не так, и он просто берет из origin, перейдите в левый нижний угол и сделайте следующее:

![](https://i.imgur.com/8rF0tz5.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/aJvW9PX.png)

Здесь ничего не произошло, потому что я только что выполнил фетч и это займет некоторое время.

</p>
</details>

<hr>

Теперь мы мерджнем изменения, которые мы только что загрузили, в нашу ветку `master`. Здесь не обязательно мерджить в master; вы можете мерджнуть и в другую ветку. Если вы просто хотите «быстро» обновить одну из ваших веток, чтобы убедиться, что ваш PR обновлён, вы можете мерджнуть коммиты и в эту ветку.

Проверьте ветку в которую вы хотите мерджнуть ПР и затем,

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/8lUaEFt.png)
![](https://i.imgur.com/7BvBPYY.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/n8cc2DN.png)
![](https://i.imgur.com/aRSawAo.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/H2L8pOp.png)

Вы также можете `git merge upstream/master [ветка куда мерджнуть]

</p>
</details>

### 6.2 Метод Pull'а

**Pulling** означает **фетчинг** (загрузку) новых веток и коммитов из удаленного репозитория, а затем их мердж в вашу ветку. Пуллинг часто проще, потому что в Git есть хорошая система для автоматического определения того, из какого удалённого репозитория вы хотите получить информацию (но она не всегда работает хорошо). 

Пуллить обычно проще и намного легче.

Мы сделаем **pull** из нашего удаленного `upstream` (основного репо SS14) и скажем ему слиться с нашей локальной `master` веткой.

Сначала `checkout` `master` ветку. Мы уже рассказывали об этом ранее. Затем,

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/XMUt6cv.png)
![](https://i.imgur.com/NHVlZ4W.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/ANqpcph.png)
![](https://i.imgur.com/kvv058A.png)
![](https://i.imgur.com/k0scDB8.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/OfHut9Y.png)

</p>
</details>

<hr>

Если оба метода прошли успешно, значит, вы успешно обновили мастер-ветку (или ту ветку, которую вы выбрали для обновления)! Делайте это регулярно и всегда перед началом работы над новой веткой.

# Дополнения

## 1. Что нужно иметь в виду

Вы более или менее изучили рабочий процесс разработки функций для SS14 с точки зрения Git, но вот некоторые вещи, которые я бы хотел вбить вам в голову:
- При создании новой штуки, *всегда всегда* создавайте новую ветку от `master`, прежде чем коммитить что-либо. Если вы случайно закоммитите изменения физики в ветку с велосипедным клаксоном, вам не поздоровится, но это поправимо (см. Ёбанный Git!!!» выше).
- **Никогда, никогда не коммитьте в RobustToolbox или любые сабмодули вроде Lidgren.Network**, если вы не знаете, что делаете. В локальном репозитории верхнего уровня эти сабмодули считаются «файлами», поэтому их легко случайно закоммитить. Не делайте этого. О том, как исправить свои ошибки, если это произошло, читайте ниже.
- Если вам нужна дополнительная помощь с Git, не стесняйтесь спрашивать в [SS14 Discord](https://discord.gg/ss14) в канал #разработка

## 2. Быстрый пример рабочего процесса

Чтобы все уложилось в голове и всё подытожить, вот пример рабочего процесса по созданию нескольких Пулл Реквестов с помощью команд Git Bash.

```python
git checkout master # Прежде чем мы создадим новую ветку, мы должны быть на master.
git fetch upstream # Мы получим все новые изменения из репозитория SS14...
git merge upstream/master # ...и объединим их в нашу ветку master.

git checkout -b my-new-feature # Создаём новую ветку для нашей фичи.
...после локальных изменений кода...
git add -A # Добавляем все наши локальные изменения в staging
git commit -m «Fix spaghetti explosions» # Коммитим их
git push origin my-new-feature # и отправляем их на наш удалённый репозиторий

# Теперь я хочу поработать над другим ПРом.

git checkout master

# Прошло не так много времени, и ничего важного не было мерджнуто,
# поэтому я не буду фетчить и мерджить изменения снова - просто новая ветка.

git checkout -b another-feature
...после локальных изменений кода...
git add -A
git commit -m «Удаляет ядерных оперативников»

# Я коммитнул изменение, но потом понял, что мой коммит был совершенно неправильным 
# и я займусь этим позже.

git revert HEAD
git checkout master

...неделю спустя...

# Было мерджнуто много нового, так что давайте обновим нашу ветку.

git fetch upstream
git merge upstream/master master
git checkout another-feature
git merge master

# Теперь внесём изменения и снова пушнем, на этот раз корректно.

...локальные изменения позже...
git add -A
git commit -m «Добавляет игровой режим Highlander»
git push origin another-feature

# Мы сделали оба PR, оба были объединены, так что на этом мы закончили

git checkout master
git branch -d my-new-feature # Удаляем обе старые ветки
git branch -d another-feature

```

# Глоссарий: Внутренние механизмы Git

Для справки, вот небольшой глоссарий понятий и терминов Git, объясняющий их более подробно и в одном месте.

- **'Ветки'**(Branch) это последовательность коммитов (история изменения состояния репозитория). Каждый коммит в ветке имеет «родителя» (parent commit) - коммит, на основе которого был получен текущий. В репозитории может быть несколько веток (в случаях, когда к одной версии репозитория применяется несколько независимых изменений).
- **'Репозиторий'** совокупность файлов, состояние которых отслеживается, и история их изменений. По факту, репозиторий — это проект, над которым ведется работа, и все изменения в этом проекте. Для отслеживания состояния файла его необходимо добавить в репозиторий, репозитории живут на сайтах по типу [GitHub](https://github.com/space-wizards/space-station-14).
- **'Ремоуты'** это имена и ссылки на удаленные репозитории, которые может использовать ваш локальный репозиторий.
- **'Сабмодули'** это репозитории, которые находятся внутри другого репозитория.
- **'Форки'** это репозитории, которые основаны на другом репозитории. Если вы собираетесь сделать ПР в репозиторий SS14, вам нужно сначала его форкнуть.
- **"Рабочее дерево"**(Working tree) - это все файлы, папки и прочее, что есть в репозитории.
- **'Стейджинг'**(Staging) означает добавление (с помощью `git add`) изменений из вашего рабочего дерева в «staging area», где над ними могут быть произведены некоторые действия.
- **'Коммиты'** это снимки рабочего дерева репозитория в определённый момент времени. По сути, это точка сохранения. Коммит» - это просто список файлов, которые были изменены с момента последнего коммита, а изменения, которые "коммитнули", - это изменения, которые вы "стейджнули"
- **'Чекаут'**(Checkout) - это акт переключения на другую ветку, чтобы вы могли работать с ней или просматривать её изменения локально.
- **'Мерджинг'** это акт интеграции изменений из одной ветки в другую ветку.
- **'Мердж конфликты'** возникают, когда интеграция изменений из одной ветки в другую не может быть выполнена автоматически, потому что обе ветки изменяют одну и ту же область файла или их изменения взаимоисключают друг друга каким-либо другим способом.
- **'Фетчинг'**(Fetching) означает получить ветки и коммиты удаленного репозитория, но на самом деле... ничего с ними пока не делать. Они просто будут обновлены, если вы захотите проверить или мерджнуть их позже.. 
- **'Пуллинг'**(Pulling) это акт интеграции изменений из ветки удаленного репозитория в вашу локальную ветку.
- **'Пулл Реквесты'**(Pull Request) это специфическое для GitHub действие, позволяющее запросить слияние вашей локальной ветки и всех ее изменений с веткой другого репозитория.
- **'Пушинг'**(Pushing) это акт интеграции ваших локальных изменений в удаленный репозиторий.

Существует гораздо больше команд и концепций, чем эта, но это все, что вам действительно нужно знать для базовой разработки.

# Приложение A: Полезные советы и рекомендации

Есть вещи, которые я не описал, но они почти неизбежно понадобятся вам в какой-то момент. Я быстро расскажу обо всех этих **исключительно git-командах в Git Bash**, но их несложно найти и в других программах (те же ключевые слова, просто ищите их). Я рекомендую использовать их специальные руководства, потому что я не знаю TortoiseGit / SmartGit / GitKraken / Github Desktop достаточно хорошо, чтобы помочь вам с более сложными вещами.

Одно замечание, поскольку оно часто встречается здесь: **`HEAD` - это модное название коммита, на котором вы сейчас находитесь**. Не более того. Ветви тоже технически являются причудливыми названиями коммитов, но вам это пока не нужно знать.

Многое из этого можно найти в «Ёбанный Git!!!», (см. ресурсы выше)

## Мердж Конфликты

*WIP Я напишу лучшее руководство для этого позже, потому что это важно*

Мерзкий маленький мейнтейнер сказал вам убрать «мердж конфликты», иначе ваш PR «не будет мерджнут. Вот засранец! К счастью, это не так уж сложно.

Сначала вам нужно обновить локальную ветку `master branch`. Как это сделать, смотрите выше.

Когда вы запустите `git merge master [local branch]`, он либо сделает это чисто (ура), либо скажет, что вам нужно разрешить конфликты (меххх). 

Чтобы разрешить конфликты вручную, достаточно зайти в конфликтующие файлы, удалить всю ерунду типа `>>>>HEAD` и `===== <<<<master` (просто отмечает, откуда произошли изменения), а затем отредактировать файл так, чтобы он правильно объединял оба набора изменений. Иногда это легко, иногда трудно. Если это сложно, то вы, вероятно, знаете, что делаете. После этого просто сделайте `git commit`.

В Atlassian есть очень хорошее руководство по этому вопросу [здесь](https://www.atlassian.com/git/tutorials/using-branches/merge-conflicts)

## Проверяем историю

`git log --oneline` - ваш друг. Он показывает короткие хэши коммитов (уникальные идентификаторы коммитов), их сообщения, а также их ветки и теги.

## Избавление от локальных изменений

Возможно, вы случайно внесли изменения, которых не хотели, и не хотите возиться с созданием совершенно новой ветки или чего-то подобного - но вы еще не коммитнули эти изменения.

```
git reset --hard HEAD
```

Это просто означает «изменить рабочее дерево на текущий коммит, до любых локальных изменений. **Вы не сможете вернуть эти локальные изменения, если сделаете это, так что будьте осторожны.**

## Снятие изменений с постановки

Вот блядь, я случайно стейджнул RobustToolbox. Не страшно!

```
git reset HEAD [file]
```

В качестве альтернативы, чтобы удалить все:

```
git reset HEAD
```
## Отмена сделанного вами коммита

Вот чёрт, ваш ЕРП спрайт ксеноморфа случайно попал в коммит/вы случайно закоммитили в сабмодуль! Что теперь? Есть два решения:

```
git revert HEAD
```

Это создаст новый коммит, отменяющий текущий коммит, а затем закоммитит его. Хе-хе коммит. 

Если вы хотите отменить другой коммит, вы можете проверить его хэш в `git log --oneline` и затем вызвать `git revert [commit hash]`. В Git'е есть более надёжная система для этого; вы можете сделать `git revert HEAD~1`, чтобы отменить коммит перед текущим, или `git revert HEAD~2`, чтобы отменить тот, который был перед этим. `~1` просто означает «1 коммит перед HEAD».

Альтернативный вариант,

```
git reset --hard HEAD~1
```

**Я не рекомендую делать это, если вы не осознаёте, что делаете.**

Для тех случаев, когда вы РЕАЛЬНО не хотите, чтобы кто-то узнал об ерп ксеноморфе, которого вы только что коммитнули. Этот метод переписывает историю, поэтому он не подходит для совместной разработки. Если вы сделаете это, вам нужно будет выполнить принудительный push (`git push origin [branch] --force`), иначе он не сработает. Принудительный пуш может быть опасным, поэтому, опять же, убедитесь, что вы знаете, что делаете.

## Проверка изменений в PR локально

Окей, это немного сложно. Есть несколько способов сделать это:

### Github CLI

Установите модный CLI от github и сделайте следующее:

```
gh pr checkout [номер ПРа]
```

Аккуратно.

### Изменение .git/config

Зайдите в папку .git (по умолчанию она скрыта - возможно, потребуется включить отображение скрытых папок в Windows) и откройте файл 'config'. Там должен быть фрагмент, который выглядит примерно так:

```
[remote «upstream»]
	url = https://github.com/space-wizards/space-station-14
	fetch = +refs/heads/*:refs/remotes/upstream/*
```

Добавьте к этому строку, которая гласит `fetch = +refs/pull/*/head:refs/remotes/upstream/pr/*`, так что теперь эта секция должна выглядеть следующим образом:

```
[remote «upstream»]
        url = https://github.com/space-wizards/space-station-14
        fetch = +refs/heads/*:refs/remotes/upstream/*
        fetch = +refs/pull/*/head:refs/remotes/upstream/pr/*
```

Теперь пропишите `git fetch upstream`. Этот метод хорош, если вы мейнтейнер, но он также... собирает все ветки, которые еще не закрыты, из всех PR, которые были открыты, так что это не лучший вариант, если вам нужно только что-то одно. Отсюда вы можете сделать `git checkout upstream/pr/[номер ПРа]`, чтобы проверить их ветку. В принципе, это то же самое, что делает GitHub CLI, но менее сложное.


### Добавление нового ремоута

Этот метод немного отстойный, потому что занимает много времени, но если вы хотите проверить чужой форк игры и его ветки, то это довольно удобно.

На самом деле это не так уж и сложно, но если вы не очень хорошо знаете Git, это может сбить с толку. Настройте удалённый доступ к удалённому репозиторию пользователя, получите его ветки, а затем проверьте его ветку:

```
git remote add [имя пользователя] https://github.com/[имя пользователя]/space-station-14
git fetch [имя пользователя]
git checkout [имя пользователя]/[название ветки]
```

Это также позволит вам делать PR в их удаленную ветку, если вы того пожелаете.